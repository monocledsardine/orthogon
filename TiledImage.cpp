#include "TiledImage.h"int TileParams::tileCountHorizontal(int surfaceWidth) const{	if (proportions.x + padding.x <= 0)		return 0;			if (offset.x < surfaceWidth)	{		int result = (surfaceWidth - offset.x) / (proportions.x + padding.x);		if ((surfaceWidth - offset.x) % (proportions.x + padding.x) != 0)			++result;		return result;	}		return 0;}int TileParams::tileCountVertical(int surfaceHeight) const{	if (proportions.y + padding.y <= 0)		return 0;			if (offset.y < surfaceHeight)	{		int result = (surfaceHeight - offset.y) / (proportions.y + padding.y);		if ((surfaceHeight - offset.y) % (proportions.y + padding.y) != 0)			++result;		return result;	}		return 0;}sf::IntRect TileParams::getTile(int index, int surfaceWidth, int surfaceHeight, bool adjustSize) const{	const int numHorizontal = tileCountHorizontal(surfaceWidth);		if (numHorizontal < 1)		return sf::IntRect();		sf::IntRect rect;	rect.left = (index % numHorizontal)*(proportions.x + padding.x) + offset.x;	rect.top = (index / numHorizontal)*(proportions.y + padding.y) + offset.y;	if (adjustSize)	{		rect.width = proportions.x <= surfaceWidth-rect.left ? proportions.x : surfaceWidth-rect.left;		rect.height = proportions.y <= surfaceHeight-rect.height ? proportions.y : surfaceHeight-rect.top;	}	else	{		rect.width = proportions.x;		rect.height = proportions.y;	}	return rect;}TileSet::TileSet(){}	TileSet::TileSet(const TileParams& params, int width, int height, int max){	int w(params.tileCountHorizontal(width));	int h(params.tileCountVertical(height));		for (int i = 0; i < max || (i < w*h && max <= 0); ++i)		push_back(params.getTile(i, width, height));}TiledImage::TiledImage(){}TiledImage::TiledImage(const std::string& filename, const TileParams& params){	loadFromFile(filename);	loadTiles(TileSet(params, getSize().x, getSize().y));}void TiledImage::loadTiles(const TileSet& ts){	tiles = ts;}